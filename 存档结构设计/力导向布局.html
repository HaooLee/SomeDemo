<!DOCTYPE html>
<html>
<head>
  <style>
    canvas {
      border: 1px solid #000000;
    }
  </style>
</head>
<body>
<canvas id="graphCanvas" width="1000" height="1000"></canvas>

<script>
  // 定义节点和边的数据
  const nodes = [
    { id: 'node1', label: 'Node 1' },
    { id: 'node2', label: 'Node 2' },
    { id: 'node3', label: 'Node 3' },
    { id: 'node4', label: 'Node 4' },
  ];
  const links = [
    { source: 'node1', target: 'node2' },
    { source: 'node2', target: 'node3' },
    { source: 'node3', target: 'node4' },
    { source: 'node4', target: 'node2' },
  ];

  // 创建 Canvas 元素
  const canvas = document.getElementById('graphCanvas');
  const ctx = canvas.getContext('2d');

  // 初始化节点位置
  nodes.forEach((node) => {
    node.x = Math.random() * (canvas.width - 20) + 10;
    node.y = Math.random() * (canvas.height - 20) + 10;
  });

  // 设置布局参数
  const repulsionForce = 100; // 斥力系数
  const springLength = 100; // 弹簧长度
  const springForce = 1; // 弹簧系数
  const damping = 0.9; // 阻尼系数

  // 绘制节点和边
  function drawGraph() {
    // 清空画布
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 绘制边
    links.forEach((link) => {
      const sourceNode = nodes.find((node) => node.id === link.source);
      const targetNode = nodes.find((node) => node.id === link.target);

      ctx.beginPath();
      ctx.moveTo(sourceNode.x, sourceNode.y);
      ctx.lineTo(targetNode.x, targetNode.y);
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 1;
      ctx.stroke();
    });

    // 绘制节点
    nodes.forEach((node) => {
      ctx.beginPath();
      ctx.arc(node.x, node.y, 10, 0, Math.PI * 2);
      ctx.fillStyle = '#FF0000';
      ctx.fill();
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = '#000000';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(node.label, node.x, node.y);
    });
  }

  // 更新节点位置
  function updatePositions() {
    nodes.forEach((node, index) => {
      if(index === 0){
        return
      }
      let forceX = 0;
      let forceY = 0;

      // 计算斥力
      nodes.forEach((otherNode) => {
        if (node !== otherNode) {
          const dx = otherNode.x - node.x;
          const dy = otherNode.y - node.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const repulsion = repulsionForce / (distance * distance);
          forceX += repulsion * (dx / distance);
          forceY += repulsion * (dy / distance);
        }
      });

      // 计算拉力
      links.forEach((link) => {
        if (link.source === node.id) {
          const targetNode = nodes.find((n) => n.id === link.target);
          const dx = targetNode.x - node.x;
          const dy = targetNode.y - node.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const spring = springForce * (distance - springLength);
          forceX += spring * (dx / distance);
          forceY += spring * (dy / distance);
        }
      });

      // 更新节点位置
      node.x += forceX;
      node.y += forceY;

      // 应用阻尼
      node.x *= damping;
      node.y *= damping;
    });
  }

  // 动画循环
  function animate() {
    updatePositions();
    drawGraph();
    requestAnimationFrame(animate);
  }

  // 调用绘制函数
  drawGraph();
  animate();
</script>
</body>
</html>