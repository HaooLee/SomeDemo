<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        #cvs {
            border: 1px solid #000;
        }
    </style>
</head>
<body>
<canvas id="cvs" width="1920" height="1000"></canvas>

<script>
  const canvas = document.getElementById('cvs');
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    translate.x -= e.deltaX;
    translate.y -= e.deltaY;
    draw();
  });
  canvas.addEventListener('contextmenu', function (event) {
    event.preventDefault();
  });
  canvas.addEventListener('mousedown', handleClick);

  function handleClick(event) {
    const x = event.offsetX;
    const y = event.offsetY;
    nodes[1] = {
      x: x - translate.x,
      y: y - translate.y,
    };
    draw();
  }

  const ctx = canvas.getContext('2d');
  const translate = {x: 110, y: 110};

  const nodeRect = {
    width: 200,
    height: 100,
  };

  const nodes = [
    {
      x: 11,
      y: 22,
    }, {
      x: 500,
      y: 400,
    }
  ];

  const offset = 60;

  function searchPolyline(sNode, tNode) {
    const sBBox = getExpandedBBox(sNode, offset);
    const tBBox = getExpandedBBox(tNode, offset);

    const sPoints = getPortPosition(sBBox, 'out');
    const tPoints = getPortPosition(tBBox, 'entry');
    let points = getConnectablePoints(sBBox, tBBox, sPoints, tPoints);
    points = filterConnectablePoints(points, sBBox, tBBox);
    drawPoints(points);

    // 找到最短路径
    const path = AStar(sPoints, tPoints, points, sNode, tNode) || [];

    return [getPortPosition(getBBox(sNode), 'out'), ...path, getPortPosition(getBBox(tNode), 'entry')];
  }

  // 查找最短路径 A*算法思路
  function AStar (startPoint, endPoint, points, sNode, tNode) {
    const paths = [];
    const start = {x: startPoint.x, y: startPoint.y, g: 0};
    const end = {x: endPoint.x, y: endPoint.y};
    const openList = [start];
    const closeList = [];
    while (openList.length > 0) {
      const current = openList.shift();
      closeList.push(current);
      if (current.x === end.x && current.y === end.y) {
        // 找到了
        let temp = current
        console.log(temp.g)
        while (temp) {
          paths.push(temp);
          temp = temp.parent;
        }
        return paths.reverse();
      }
      const neighbors = getNeighbors(current, points);
      for (let neighbor of neighbors) {
        if (isInList(neighbor, closeList)) {
          continue;
        }

        let g = current.g + getDistance(current, neighbor);
        if (!isInList(neighbor, openList)) {
          if (isSegmentCrossingBBox(current, neighbor, getExpandedBBox(sNode,offset - 0.001)) || isSegmentCrossingBBox(current, neighbor, getExpandedBBox(tNode,offset - 0.001) )) {
            g += 999999
          }
          neighbor.g = g;
          neighbor.parent = current;
          openList.push(neighbor);
        } else {
          if (g < neighbor.g) {
            neighbor.g = g;
            neighbor.parent = current;
          }
        }
      }
      openList.sort((a, b) => a.g - b.g);
    }
    return null;
  }

  function isInList(node, list) {
    for (let item of list) {
      if (item.x === node.x && item.y === node.y) {
        return true;
      }
    }
    return false;
  }

  //获取上下左右最近的点
  function getNeighbors(node, points) {
    const neighbors = {
        top: null,
        bottom: null,
        left: null,
        right: null,
    }
    for (let point of points) {
      if (point.x === node.x && point.y === node.y) continue;
      if (point.x === node.x) {
        if (point.y < node.y) {
          if (!neighbors.top || neighbors.top.y < point.y) {
            neighbors.top = point;
          }
        } else {
          if (!neighbors.bottom || neighbors.bottom.y > point.y) {
            neighbors.bottom = point;
          }
        }
      } else if (point.y === node.y) {
        if (point.x < node.x) {
          if (!neighbors.left || neighbors.left.x < point.x) {
            neighbors.left = point;
          }
        } else {
          if (!neighbors.right || neighbors.right.x > point.x) {
            neighbors.right = point;
          }
        }
      }
    }
    const result = [];
    for (let key in neighbors) {
      if (neighbors[key]) {
        result.push(neighbors[key]);
      }
    }

    // console.log(result)
    return result;
  }

  function isSegmentCrossingBBox  (p1, p2, bbox) {
    if (bbox.width || bbox.height) {
      const [pa, pb, pc, pd] = getPointsFromBBox(bbox);
      return (
        isSegmentsIntersected(p1, p2, pa, pb) ||
        isSegmentsIntersected(p1, p2, pa, pd) ||
        isSegmentsIntersected(p1, p2, pb, pc) ||
        isSegmentsIntersected(p1, p2, pc, pd)
      );
    }
    return false;
  }

  function isSegmentsIntersected (p0, p1, p2, p3) {
    const v1x = p2.x - p0.x;
    const v1y = p2.y - p0.y;
    const v2x = p3.x - p0.x;
    const v2y = p3.y - p0.y;
    const v3x = p2.x - p1.x;
    const v3y = p2.y - p1.y;
    const v4x = p3.x - p1.x;
    const v4y = p3.y - p1.y;

    const pd1 = v1x * v2y - v1y * v2x;
    const pd2 = v3x * v4y - v3y * v4x;
    const pd3 = v1x * v3y - v1y * v3x;
    const pd4 = v2x * v4y - v2y * v4x;

    return pd1 * pd2 <= 0 && pd3 * pd4 <= 0;
  }

  function getPointsFromBBox (bbox) {
    return [
      {
        x: bbox.minX,
        y: bbox.minY,
      },
      {
        x: bbox.maxX,
        y: bbox.minY,
      },
      {
        x: bbox.maxX,
        y: bbox.maxY,
      },
      {
        x: bbox.minX,
        y: bbox.maxY,
      },
    ];
  }

  function getDistance(p1, p2) {
    return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
  }

  function getBBox(node) {
    return {
      width: nodeRect.width,
      height: nodeRect.height,
      x: node.x,
        y: node.y,
      minX: node.x - nodeRect.width / 2,
      minY: node.y - nodeRect.height / 2,
      maxX: node.x + nodeRect.width / 2,
      maxY: node.y + nodeRect.height / 2,
    };
  }

  function getExpandedBBox(node, offset) {
    // 实现获取带偏移量的包围盒的逻辑
    return {
      x: node.x,
      y: node.y,
      width: nodeRect.width + offset * 2,
      height: nodeRect.height + offset * 2,
      minX: node.x - nodeRect.width / 2 - offset,
      minY: node.y - nodeRect.height / 2 - offset,
      maxX: node.x + nodeRect.width / 2 + offset,
      maxY: node.y + nodeRect.height / 2 + offset,
    };
  }

  function getConnectablePoints(sBBox, tBBox, sPoints, tPoints) {
    const points = [];
    // 获取起点和终点组成的包围盒
    const lineBBox = getBBoxFromVertexes(sPoints, tPoints);
    // 获取开始节点和结束节点的包围盒的外接矩形包围盒
    const outerBBox = getOuterBBox(sBBox, tBBox);
    points.push(...getVertexesFromBBox(sBBox))
    points.push(...getVertexesFromBBox(tBBox));
    points.push(...getVertexesFromBBox(lineBBox));
    points.push(...getVertexesFromBBox(outerBBox));

    const bboxes = [sBBox, tBBox, lineBBox, outerBBox];

    for (let bbox of bboxes) {
      points.push(...getBBoxCrossPointsByPoint(bbox, getBBoxCenter(outerBBox) ));
    }

    // drawBBox(sBBox, 'fill', 'rgba(2,70,23,0.31)');
    // drawBBox(tBBox, 'fill', 'rgba(2,70,23,0.31)');
    // drawBBox(lineBBox, 'stroke', 'rgba(2,70,23,0.31)');
    // drawBBox(outerBBox, 'stroke', 'rgba(2,70,23,0.31)');
    // drawPoints(points)
    return points;
  }

  function getPortPosition(bbox, portType) {
    if (portType === "entry") {
      return {
        x: bbox.minX,
        y: bbox.y,
      };
    }
    return {
      x: bbox.maxX,
      y: bbox.y,
    };

    // return {
    //   x: bbox.x,
    //   y: bbox.minY,
    // };
  }

  function filterConnectablePoints(points, sBBox, tBBox) {
    const filteredPoints = [];
    for (let point of points) {
      if (!isPointInRect(point, sBBox) && !isPointInRect(point, tBBox)) {
        filteredPoints.push(point);
      }
    }
    return filteredPoints;
  }

  function isPointInRect(point, bbox) {
    return point.x > bbox.minX && point.x < bbox.maxX && point.y > bbox.minY && point.y < bbox.maxY;
  }

  function getVertexesFromBBox(bbox) {
    return [
      {x: bbox.minX, y: bbox.minY},
      {x: bbox.maxX, y: bbox.minY},
      {x: bbox.maxX, y: bbox.maxY},
      {x: bbox.minX, y: bbox.maxY},
    ];
  }

  function getBBoxCenter (bbox) {
    return {
      x: bbox.x,
      y: bbox.y,
    };
  }

  function getBBoxXCrossPoints (bbox, x) {
    return [
      {
        x,
        y: bbox.minY,
      },
      {
        x,
        y: bbox.maxY,
      },
    ];
  }

  function getBBoxYCrossPoints (bbox, y){
    return [
      {
        x: bbox.minX,
        y,
      },
      {
        x: bbox.maxX,
        y,
      },
    ];
  }

 function getBBoxCrossPointsByPoint (bbox, point) {
    return getBBoxXCrossPoints(bbox, point.x).concat(getBBoxYCrossPoints(bbox, point.y));
 }

  function getBBoxFromVertexes(point1, point2) {
    const minX = Math.min(point1.x, point2.x);
    const minY = Math.min(point1.y, point2.y);
    const maxX = Math.max(point1.x, point2.x);
    const maxY = Math.max(point1.y, point2.y);
    const x = minX + (maxX - minX) / 2;
    const y = minY + (maxY - minY) / 2;
    const width = maxX - minX;
    const height = maxY - minY;
    return {minX, minY, maxX, maxY, x, y, width, height};
  }

  function getOuterBBox(bbox1, bbox2) {
    const minX = Math.min(bbox1.minX, bbox2.minX);
    const minY = Math.min(bbox1.minY, bbox2.minY);
    const maxX = Math.max(bbox1.maxX, bbox2.maxX);
    const maxY = Math.max(bbox1.maxY, bbox2.maxY);
    const x = minX + (maxX - minX) / 2;
    const y = minY + (maxY - minY) / 2;
    const width = maxX - minX;
    const height = maxY - minY;
    return {minX, minY, maxX, maxY, x, y, width, height};
  }

  function drawNode(nodes) {
    nodes.forEach((node) => {
      ctx.beginPath();
      //先绘制bbox
      // ctx.fillRect(node.x - 2, node.y - 2, 4, 4);
      ctx.fillStyle = 'rgba(102,222,194,0.31)';
      ctx.fillRect(node.x - nodeRect.width / 2, node.y - nodeRect.height / 2, nodeRect.width, nodeRect.height);

    });
  }

  function drawPoints(points, color = '#FF0000',radius = 3) {
    points.forEach((point) => {
      ctx.beginPath();
      ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
      ctx.fillStyle = color
      ctx.fill();
    });
  }

  function drawBBox(bbox, drawType, color) {
    ctx.save();
    ctx.beginPath();
    if (drawType === 'fill') {
      ctx.fillStyle = color;
      ctx.fillRect(bbox.minX, bbox.minY, bbox.width, bbox.height);
    } else {
      ctx.strokeStyle = color;
      ctx.setLineDash([5, 5]);
      ctx.strokeRect(bbox.minX, bbox.minY, bbox.width, bbox.height);
    }
    ctx.restore();
  }

  function drawEdge(path, color = '#000') {
    if (!path) return;
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for (let i = 1; i < path.length; i++) {
      ctx.lineTo(path[i].x, path[i].y);
    }
    ctx.strokeStyle = color;
    ctx.stroke();
  }


  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(translate.x, translate.y);
    drawNode(nodes);
    const path = searchPolyline(nodes[0], nodes[1]);
    drawEdge(path);
    ctx.restore();
  }

  draw();
</script>
</body>
</html>